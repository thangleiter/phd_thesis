% mainfile: ../../main.tex
\chapter{Conclusion and outlook}\label{ch:speck:conclusion}
\mylettrine{I}{n} this part, I presented the \pyspeck \python package for interactive, backend-agnostic spectrum acquisition.

\paragraph{Outlook.\label{par:speck:outlook}}
There are several possible avenues for future development of the \pyspeck package.
An obvious case is adding support for more \gls{daq} hardware instruments by implementing \code{DAQ} interfaces.
Modular devices such as those offered by \href{https://www.qblox.com/research}{QBLOX} and \href{https://www.quantum-machines.co/}{Quantum Machines} are on track to become the new standard in quantum technology labs.
Implementing drivers for these instruments would benefit the adoption of both the instruments and the \pyspeck package.

Next, incorporating noise spectroscopy into the standard measurement workflow of quantum device experiments would allow experimentalists to quickly gauge noise levels as they are performing measurements.
If for some reason the noise changed\sidenote{
    As it happens often, unfortunately.
}
the experimentalist could quickly obtain insight into the noise by analyzing the spectrum.
In a client-server architecture, which is inherently asynchronous, such as Zurich Instrument's \href{https://www.zhinst.com/ch/en/instruments/labone/labone-instrument-control-software}{LabOne} software, this is already possible using the web interface.
But of course the strength of the \pyspeck package stems from its capacity to be utilized in conjunction with any hardware instrument.

\begin{marginlisting}
    \begin{py}
        # daq/tee.py
        import dataclasses
        import threading
        import multiprocessing as mp

        from .base import DAQ

        @dataclasses.dataclass
        class TeeDAQ(DAQ):
            settings: mp.managers.DictProxy
            data_queue: mp.JoinableQueue
            stop_event: threading.Event

            def setup(self, **_):
                settings = self.DAQSettings(self.settings)
                return settings.to_consistent_dict()

            def acquire(self, **_):
                while not self.stop_event.is_set():
                    yield self.data_queue.get(block=True)
    \end{py}
    \caption[\code{TeeDAQ} template]{
        Template design for a proxy \code{DAQ} implementation to stream noise spectra from an external measurement framework.
        The \code{settings} attribute is a dictionary proxy shared between processes and used to pass acquisition parameters from the measurement framework to \pyspeck.
    }
    \label{lst:speck:conclusion:tee}
\end{marginlisting}

One way to implement such functionality would be to introduce a proxy \code{DAQ} subclass to be used together with the live mode presented in \cref{subsec:speck:software:features:live_view}.
This proxy class would serve as an interface to external measurement software and expose two attributes; first, a data queue, into which the external code could place arbitrary time series data that was obtained during some measurement, and second, a shared dictionary to hold acquisition parameters as these might change between measurements.
Because the live view mode runs in the background, the external measurement framework could push data to the queue whenever new data was taken without obstructing the measurement workflow.

\Cref{lst:speck:conclusion:tee} shows a template design for such a \code{TeeDAQ} class.
The \code{setup()} method ignores the input parameters and instead obtains the current settings from the shared \code{settings} proxy.
Similarly, instead of fetching data from an instrument itself, the \code{acquire()} method attempts to fetch data from the shared \code{data_queue} and blocks the thread if no data is present, thereby efficiently idling and consuming no resources unless triggered by the external caller.
A measurement framework would then interact with the \code{TeeDAQ} object as exemplarized by the following code:
\begin{py}
    spect = Spectrometer(TeeDAQ(...))
    view = spect.live_view()
    ...
    data = measure(fs, n_pts)
    spect.daq.settings.update(fs=fs, n_pts=n_pts)
    spect.daq.data_queue.put(data)
\end{py}
Measurement frameworks integrating with this interface could thus provide experimentalists live feedback on current noise levels with negligible overhead and minimal code adaptation.

Finally, it might be useful to not only allow estimating \glspl{psd} but also \emph{cross-spectra}.
The cross-spectrum is the Fourier transform of not the auto-correlation but the cross-correlation function $C(\tau)$ (\cf \cref{eq:speck:autocorrelation}) between two random processes.
Take a set of processes $\{x_1(t), x_2(t), \dotsc, x_n(t)\}$ that correspond to noise measured at different locations in a sample.
The cross-correlation function between variables $x_i$ and $x_j$ is then given by\sidenote{
    Again assuming wide-sense stationary processes.
}
\begin{align}\label{eq:speck:conclusion:crosscorrelation}
    C_{ij}(\tau) = \expval{x_i(t)\conjugate x_j(t + \tau)}.
\end{align}
This function (and its Fourier pair the cross-spectrum) quantifies the degree of correlation between noise at site $i$ and noise at site $j$.
It is straightforward to see that for quantum processors, for example, these types of correlations could significantly impact the operation, and error correction in particular~\cite{Aharonov2006,Nickerson2019,Clader2021}.
