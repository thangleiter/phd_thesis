% mainfile: ../../main.tex
\chapter{The \texttt{filter\_functions} software package}\label{ch:ff:software}
\AutoLettrine{In} this section we give a brief overview over the \filterfunctions software package implementing the main features of the formalism derived above.\sidenote{
    For more details we refer the reader to the \href{https://filter-functions.readthedocs.io/en/latest/}{documentation}.
}
This includes the calculation of the decay amplitudes \decayamps, frequency shifts \freqshifts, and fidelities as well as the calculation of the control matrices for single gates and both generic and periodic sequences of gates.
Moreover, control matrices may be efficiently extended to and merged on larger Hilbert spaces.
Calculations using unitary conjugation instead of transfer matrices are implemented but at this point not available in the high-level \gls{api}.

Our software is written in Python and published under the GPLv3 license~\cite{Hangleiter_ff}.
It features a broad coverage through unit tests and extensive \gls{api} documentation as well as didactic examples (see also \cref{ch:ff:examples}).
The package relies on the \numpy~\cite{Harris2020} and \scipy~\cite{Virtanen2020} libraries for vectorized array operations.
Data visualization is handled by \matplotlib~\cite{Hunter2007}.
For tensor multiplications with optimized contraction order we use \opteinsum~\cite{Smith2018} for which \sparse~\cite{Pydata2019}, a library aiming to extend the \scipy sparse module to multi-dimensional arrays, serves as a backend in the calculation of the trace tensor from \cref{eq:ff:trace_tensor}.
Lastly, the package is written to interface with \qopt~\cite{Teske2022} and \qutip~\cite{Johansson2012}, frameworks for the simulation and optimization of open quantum systems, and mirrors the latter's data structure for Hamiltonians ensuring easy interoperability between the two.

\section{Package overview}\label{sec:ff:software:overview}
In the \filterfunctions package all operations are understood as sequences of pulses that are applied to a quantum system.
These pulses are represented by instances of the \pulsesequence class which holds information about the physical system (control and noise Hamiltonians) as well as the mathematical description (\eg the basis used for the Liouville representation).
As indicated above, the Hamiltonians $\Hc(t)$ and $\Hn(t)$ are given in a similar structure as in \qutip.
That is, a Hamiltonian is expressed as a sum of Hermitian operators with the time dependence encoded in piecewise constant coefficients so that
\begin{subequations}\label{eq:ff:hamiltonian:software}
\begin{gather}
    \Hc(t) = \sum_i a\gth{g}_i A_i = \mr{const.} \label{eq:ff:hamiltonian:software:control} \\
    \Hn(t) = \sum_\alpha s\gth{g}_\alpha B_\alpha = \mr{const.} \label{eq:ff:hamiltonian:software:noise}
\end{gather}
\end{subequations}
for $t\in (t_{g-1}, t_g], g\in\lbrace 1,\dotsc,G\rbrace$ and where the $a\gth{g}_i$ are the amplitudes of the $i$th control field.
Note that the noise variables $b_\alpha(t)$ are missing from \cref{eq:ff:hamiltonian:software:noise} because they are captured by the spectral density $S(\omega)$.
In the software, \cref{eq:ff:hamiltonian:software:control,eq:ff:hamiltonian:software:noise} are represented as lists whose $i$th element corresponds to a sublist of two elements: the $i$th operator and the $i$th coefficients $[a_i\gth{0},\dotsc,a_i\gth{G}]$.

The \pulsesequence class provides methods to calculate and cache the filter function according to \cref{eq:ff:control_matrix:pulse:freq}.
Alternatively, filter functions may also be cached manually to permit using the package with analytical solutions for the control matrix.
Concatenation of pulses is implemented by the functions \code{concatenate()} and \code{concatenate_periodic()} which will attempt to use the cached attributes of the \pulsesequence instances representing the pulses to efficiently calculate the filter function of the composite pulse following \cref{eq:ff:control_matrix:sequence:freq} and \cref{eq:ff:control_matrix:sequence:periodic:simplified}, respectively.

Operator bases fulfilling \cref{eq:ff:basis} are implemented by the \code{Basis} class.
There are two predefined types of bases:
\begin{enumerate}
    \item Pauli bases $\mathsf{P}_n$ for $n = 2^d$ qubits from \cref{eq:ff:basis:pauli} and
    \item \gls{ggm} bases $\mathsf{Î›}_d$ of arbitrary dimension $d$ from \cref{eq:ff:basis:ggm}.
\end{enumerate}
The Pauli basis is both unitary and separable while the \gls{ggm} basis is sparse for large dimensions but neither unitary nor separable.
As mentioned in \cref{sec:ff:performance:extending_hilbert_spaces} (see also \cref{sec:ff:examples:qft}), using a separable basis can provide significant performance benefits for calculating the filter functions of algorithms.
On the other hand, a sparse basis makes the calculation of the trace tensor $T_{ijkl}$ and therefore also of the error transfer matrix \liouvUe much faster (\cf \cref{sec:ff:performance:basis}).
Additionally, the user can define custom bases using the class constructor.

The error transfer matrix \liouvUe can be calculated for a given pulse and noise spectrum using the \code{error_transfer_matrix()} function.
Various other quantities can be computed from \liouvUe as outlined in \cref{sec:ff:theory:derived_quantities}.
Furthermore, the package includes a plotting module that offers several functions, \eg for the visualization of filter functions or the evolution of the Bloch vector using \qutip.

\section{Workflow}\label{sec:ff:software:workflow}
We now give a short introduction into the workflow of the \filterfunctions package by showing how to calculate the dephasing filter function of a simple Hahn \gls{se} sequence~\cite{Hahn1950} as an example.
The sequence consists of a single $\pi$-pulse of finite duration around the $x$-axis of the Bloch sphere in between two periods of free evolution.
We can hence divide the control fields into three constant segments and write the control Hamiltonian as
\begin{equation}
    \Hc\gth{\mr{SE}}(t) = \frac{\sx}{2}\times\begin{dcases}
                                                 \flatfrac{\pi}{t_\pi},  &\mr{if\;} \tau\leq t < \tau + t_\pi \\
                                                 0,                      &\mr{otherwise} \\
    \end{dcases}
\end{equation}
with $\tau$ the duration of the free evolution period and $t_\pi$ that of the $\pi$ pulse.
For the noise Hamiltonian we only need to define the deterministic time dependence $s_\alpha(t)$ and operators $B_\alpha$ since the noise strength is captured by the spectrum $S(\omega)$.
Thus we have $s_z(t) =  1$ and $B_z = \flatfrac{\sz}{2}$ for pure dephasing noise that couples linearly to the system.

In the software, we first define a \pulsesequence object representing the \gls{se} sequence.
As was already mentioned, the control and noise Hamiltonians are given as a list containing lists for every control or noise operator that is considered.
These sublists consist of the respective operator as a \numpy array or \qutip \qobj and the amplitudes ($a_i\gth{g}$ or $s_\alpha\gth{g}$) in an iterable data structure such as a list.
We can hence instantiate the \pulsesequence with the following code:
\begin{py}
    import filter_functions as ff
    import qutip as qt
    from math import pi
    tau, t_pi = (1, 1e-3)
    # Control Hamiltonian for pi rotation in 2nd time step
    H_c = [[qt.sigmax()/2, [0, pi/t_pi, 0]]]
    # Pure dephasing noise Hamiltonian with linear coupling
    H_n = [[qt.sigmaz()/2, [1, 1, 1]]]
    # Durations of piecewise constant segments
    dt = [tau, t_pi, tau]
    ECHO = ff.PulseSequence(H_c, H_n, dt)
\end{py}
where a basis is automatically chosen since we did not specify it in the constructor in the last line.
Calculating the filter function of the pulse for a given frequency vector \code{omega} can then be achieved by calling
\begin{py}
    F = ECHO.get_filter_function(omega)
\end{py}
where \code{F} is the dephasing filter function $\FF_{zz}(\omega)$ as we only defined a single noise operator.
Finally, we calculate the error transfer matrix \liouvUe for the noise spectral density $S_{zz}(\omega) = \omega^{-2}$,
\begin{py}
    S = 1/omega**2
    U = ff.error_transfer_matrix(ECHO, S, omega)
\end{py}
This code uses the control matrix previously cached when the filter function was first computed.
Therefore, only the integration in \cref{eq:ff:decay_amplitudes:freq} and the calculation of the trace tensor in \cref{eq:ff:trace_tensor} are carried out in the last line.

An alternative approach to calculate the spin echo filter function is to employ the concatenation property.
For this, we interpret the \gls{se} as a sequence consisting of three separate pulses.
Each of the pulses has a single time segment during which a constant control is applied and concatenating the separate \pulsesequence instances yields the \pulsesequence representing a spin echo.
This way analytical control matrices may be used to calculate the control matrix of the composite sequence.
Pulses can be concatenated by using either the \code{concatenate()} function or the overloaded \code{@} operator:
\begin{py}
    # Define PulseSequence objects as shown above
    FID = ff.PulseSequence(...)
    NOT = ff.PulseSequence(...)
    # Cache the analytical control matrices at frequency omega
    FID.cache_control_matrix(omega, B_FID)
    NOT.cache_control_matrix(omega, B_NOT)
    # Concatenate the pulses
    ECHO = FID @ NOT @ FID
\end{py}
Since we have cached the control matrices of the \code{FID} and \code{NOT} pulses, that of the \code{ECHO} object is also automatically calculated and stored.
Concatenating \pulsesequence objects is implemented as an arithmetic operator of the class to reflect the intrinsic composition property of the control matrices.

Further development of the software has focused on making it available in a gate optimization and simulation framework~\cite{Teske2022a}.
Besides using it to compute decoherence effects and fidelities, analytical derivatives of the filter functions have been implemented to allow for optimizing pulse parameters in the presence of non-Markovian noise within the framework of quantum optimal control~\cite{Le2022,Teske2022}.

Additionally, building an interface with \qupulse~\cite{Humpohl2025,Humpohl2021}, a software toolkit for parametrizing and sequencing control pulses and relaying them to control hardware, would implement the capability to compute filter functions of pulses assembled in \qupulse, thereby allowing a user in the lab to easily inspect the noise susceptibility characteristics of the pulse they are currently applying to their device.
