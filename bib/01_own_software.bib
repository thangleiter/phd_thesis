@software{Hangleiter_ff,
  title = {Filter\_functions},
  author = {Hangleiter, Tobias and Nha Minh Le, Isabel and Teske, Julian D.},
  date = {2024-05-14},
  doi = {10.5281/ZENODO.4575000},
  url = {https://zenodo.org/doi/10.5281/zenodo.4575000},
  urldate = {2024-11-29},
  abstract = {What's Changed Release v.1.1.2 by @thangleiter in https://github.com/qutech/filter\_functions/pull/86 Fix tests for SciPy 1.9.0 by @thangleiter in https://github.com/qutech/filter\_functions/pull/87 Add GitHub citation file by @thangleiter in https://github.com/qutech/filter\_functions/pull/88 Fix codecov action on CI by @thangleiter in https://github.com/qutech/filter\_functions/pull/71 Fix tests and deprectations by @thangleiter in https://github.com/qutech/filter\_functions/pull/92 Drop support for Python versions 3.7,3.8 and add 3.11,3.12 by @thangleiter in https://github.com/qutech/filter\_functions/pull/90 Enhance documentation by @thangleiter in https://github.com/qutech/filter\_functions/pull/89 Fix RTD build by @thangleiter in https://github.com/qutech/filter\_functions/pull/93 Release 1.1.3 by @thangleiter in https://github.com/qutech/filter\_functions/pull/95 Full Changelog: https://github.com/qutech/filter\_functions/compare/v1.1.2...v1.1.3},
  langid = {english},
  organization = {Zenodo},
  version = {v1.1.3},
  keywords = {filter functions,nosource,physics,python,Python,quantum computing,quantum control,quantum information,qutip},
  file = {/home/tobias/Winhome/Zotero/storage/G8F3Z84Z/4575001.html}
}

@software{Hangleiter_lmt,
  title = {Lindblad\_mc\_tools},
  author = {Hangleiter, Tobias},
  date = {2024},
  url = {https://git.rwth-aachen.de/tobias.hangleiter/lindblad_mc_tools}
}

@software{Hangleiter_pyspeck,
  title = {Python-Spectrometer},
  author = {Hangleiter, Tobias and Humpohl, Simon and Beer, Max and Otten, Ren√©},
  date = {2024-11-21},
  doi = {10.5281/ZENODO.13789861},
  url = {https://zenodo.org/doi/10.5281/zenodo.13789861},
  urldate = {2024-11-29},
  abstract = {python-spectrometer This package implements data acquisition, processing, and visualization for estimating power spectral densities using Welch's method. It provides the Spectrometer class that serves as a central interface which acquires and manges the data. Several processing steps can be applied to the raw timeseries data, for instance to convert from a voltage signal to an acceleration given a known calibration from a signal conditioning unit. To demonstrate the basic features, here is some example code using the Keysight DMM qcodes driver for data acquisition: from python\_spectrometer import Spectrometer, daq from qcodes.instrument\_drivers.Keysight.Keysight\_34465A\_submodules import Keysight\_34465A dmm = Keysight\_34465A('dmm', 'some\_tcpip\_address') \# Pre-defined functions that set up and execute a measurement using a DMM spect = Spectrometer(daq.qcodes.Keysight344xxA(dmm),                      procfn=lambda V: V*1000,                      processed\_unit='mV') settings = \{'f\_min': 0.1, 'f\_max': 1000, 'phase\_of\_the': 'moon'\}  \# any other settings or metadata spect.take('a comment', n\_avg=5, **settings) spect.hide(0) spect.show('a comment')  \# same as spect.show(0) \# Save and recall functionality spect.serialize\_to\_disk('./foo') spect\_loaded = Spectrometer.recall\_from\_disk('./foo')  \# read-only because no DAQ given spect\_loaded.show\_keys() \# (0, 'a comment') You can also play around with simulated noise (requires qopt): from python\_spectrometer import Spectrometer, daq spect = Spectrometer(daq.simulator.QoptColoredNoise(lambda f, A, **\_: A/f)) spect.take('foobar', n\_avg=10, n\_seg=5, A=42) Installing If you just want to use it you can install the latest "released" version via python -m pip install python-spectrometer[complete] However, this package profits from everybody's work and the releases are infrequent. Please make a development install and contribute your changes. You can do this via python -m pip install -e git+https://git.rwth-aachen.de/qutech/python-spectrometer.git\#egg=python-spectrometer[complete] This will download the source code (i.e.~clone the git repository) into a subdirectory of the ./src argument and link the files into your environment instead of copying them. If you are on Windows you can use SourceTree which is a nice GUI for git. You can specify the source code directory with the --src argument (which needs to be BEFORE -e): python -m pip install --src some\_directory/my\_python\_source -e git+https://git.rwth-aachen.de/qutech/python-spectrometer.git\#egg=python-spectrometer[complete] If you have already downloaded/cloned the package yourself you can use python -m pip install -e .[complete]. Please file an issue if any of these instructions does not work. Documentation Some of the development of this package took place during a course taught at the II. Institute of Physics at RWTH Aachen University in the winter semester 2022/23. Targeting applied research topics too specific for lectures but too general for lab courses, several modules intended for self-learning were developed, one of which focuses on "characterizing and avoiding noise and interference in instrumentation". The material can be found here: - Part 1, - Part 2. The python\_spectrometer package has an auto-generated documentation that can be found at the Gitlab Pages. To build the documentation locally, navigate to doc/ and run make html or sphinx-build -b html source build Make sure the dependencies are installed via python -m pip install -e .[doc] in the top-level directory. To check if everything works for a clean install (requires hatch to be installed), run python -m hatch run doc:build Tests There are some basic tests in tests/ as well as a couple of doctests. You can run the tests either via python -m pytest --doctest-modules or to check if everything works for a clean install (requires hatch to be installed) python -m hatch run tests:run},
  organization = {Zenodo},
  version = {2024.11.1},
  keywords = {data acquisition,Fourier transform,noise spectroscopy,Welch's method},
  file = {/home/tobias/Winhome/Zotero/storage/XV4QAPIJ/14198682.html}
}

@software{Hangleiter_qutil,
  title = {Qutil},
  author = {Hangleiter, Tobias and Humpohl, Simon and Surrey, Paul and We, Han Na},
  date = {2024-11-21},
  doi = {10.5281/ZENODO.14200303},
  url = {https://zenodo.org/doi/10.5281/zenodo.14200303},
  urldate = {2024-11-29},
  abstract = {qutil / qutech\_util Long term goal is to gather utility functions here. The original name was qutil but we included the additional alias qutech\_util so you can install it via pipy. It is not meant as a lightweight package but some heavy dependencies like qcodes are feature gated. If you don't have a reason for a lightweight install you should install all features i.e.~qutil[complete]. If you just want to use it you can install the latest "released" version via python -m pip install qutech-util[complete] However, this package profits from everybody's work and the releases are infrequent. Please make a development install and contribute your changes. You can do this via python -m pip install -e git+https://git.rwth-aachen.de/qutech/qutil.git\#egg=qutech-util[complete] This will download the source code (i.e.~clone the git repository) into a subdirectory of the ./src argument and link the files into your environment instead of copying them. If you are on windows you can use SourceTree which is a nice GUI for git. You can specify the source code directory with the --src argument (which needs to be BEFORE -e): python -m pip install --src some\_directory/my\_python\_source -e git+https://git.rwth-aachen.de/qutech/qutil.git\#egg=qutech-util[complete] If you have already downloaded/cloned the package yourself you can use python -m pip install -e .[complete]. Please file an issue if any of these instructions does not work. Tests There is no plan for writing extensive tests for the code in this package but please try to write proper docstrings for your functions and include examples in them which can be checked via doctest. Follow the link for an example for an example :) You can run the tests either via python -m pytest --doctest-modules or to check if everything works for a clean install (requires hatch to be installed) python -m hatch run test:run Documentation The auto-generated documentation can be found at the Gitlab Pages. To build the documentation locally, navigate to doc/ and run either .\textbackslash make.bat html (on Windows), make html (on Unix), or sphinx-build -b html source build Make sure the dependencies are installed via python -m pip install -e .[doc] in the top-level directory. qutil.plotting This module contains useful classes and functions surrounding maptlotlib plots. cycle\_plots helps you cycling through many plots with the arrow keys (there are probably much better functions for this out there) plot\_2d\_dataframe helps you plot 2d data frames with numeric indices BlitManager can be used to significantly speed up plotting when certain parts of the plot, such as the artists on the canvas (lines, annotations, etc.) change but others do not (axes, labels, etc.) does not. CoordClicker and LineClicker allow some interactive selection of data. get\_rwth\_color\_cycle and the predefined rwth\_color\_cycle are cycler instances with the official RWTH corporate design colors: cycler example qutil.matlab In this module there are functions that are helpful for reading .mat files, especially those created with special measure. It depends on the optional matlab feature which is included in the complete install. If you simply want to open a random .mat file you can use hdf5storage.loadmat. Some functionality requires the matlab engine python interface to work, i.e.~python will use a MATLAB instance to open files. However, the matlab engine interface is not installed by default because the install process depends on the version and fails if MATLAB is not installed. For older MATLAB versions navigate to \$MATLAB\_INSTALL\_FOLDER/extern/engines/python and execute python setup.py install. For newer MATLAB versions you can install the engine interface via python -m pip install matlabengine. Loading matlab files with "newer" MATLAB classes like table requires connecting (and starting) MATLAB instance. The function load\_special\_measure\_with\_matlab\_engine can load most special measure scans by utilizing the MATLAB engine interface. To use it you require a "sufficiently new" version of MATLAB and then navigate to C:\textbackslash Program Files\textbackslash MATLAB\textbackslash\$VERSION\textbackslash extern\textbackslash engines\textbackslash python and call python setup.py install. Recommended: There are dataclasses like SimpleScan or VirtualScan that are a python representation of certain common scan types and have a convenience to\_xarray method. Use load\_simple\_scan\_with\_matlab\_engine or load\_virtual\_scan\_with\_matlab\_engine to load them. There are the dataclasses FigureData, AxesData and PlotData that represent matlab figure data. They help inspecting saved matlab figures with the help of a matlab engine. qutil.const This module defines all the constants you could wish for as well as functions to convert temperatures (convert\_temperature) or between wavelengths and frequencies (lambda2nu, nu2lambda). For an overview, see the module docstring. qutil.linalg This module provides several handy linear algebra functions. While some are implemented elsewhere, the implementation here is typically speedier for large arrays. For example, pauli\_expm exploits the fact that a matrix exponential of Pauli matrices can be written as a cosine times the identity matrix plus a sine times the Paulis to speed up the calculation. For an overview of the included functions, see the module docstring. qutil.ui This module collects UI helpers, such as a progress bar for loops that can be used like so: for i in qutil.ui.progressbar(range(n)):     do\_something() qutil.qi In this module there are some quantities and functions related to quantum information, like the Pauli matrices in different data types. qutil.random Here we collect functions for random numbers like random\_hermitian to generate random Hermitian matrices. qutil.itertools This module contains everything from itertools, more\_itertools and custom functions. qutil.caching Here you find decorators, functions and classes that help you implement caching like file\_cache and lru\_cache. This is helpful if you need to call computationally expensive functions with the same arguments repeatedly. qutil.io User input related functions like query\_yes\_no or a CsvLogger interface (for reading use pandas.read\_csv). to\_global\_path resolves all network drive mappings (such as Z:\textbackslash ) as well as domain names (such as \textbackslash\textbackslash janeway) to their global address (\textbackslash\textbackslash janeway.physik.rwth-aachen.de in this case). qutil.parallel Functions and classes related to parallel execution i.e.~multi-threading, multi-processing and asyncio. There is a class for periodic callbacks from another thread ThreadedPeriodicCallback. qutil.hardware This package contains little scripts to talk to various hardware devices. For example reading the leak tester via serial interface. qutil.electronics lumped\_elements Exposes the contents of fastz, a package for simple lumped-elements calculations. Overloads + and // to implement series and parallel connections, respectively. See the fastz documentation for more information. qutil.qcodes Functions to convert from and to qcodes data sets. Currently only from pandas.DataFrame to qcodes.data.data\_set.DataSet qutil.measurement This package is supposed to contain measurement-related functionality. It is currently empty besides some backward compatibility imports. spectrometer Moved to https://git.rwth-aachen.de/qutech/python-spectrometer. qutil.typecheck Functions and decorators to help with runtime typechecking. Notably the @check\_literals decorator to ensure that arguments match an annotated literal. Imports the typeguard which provides the powerful @typechecked decorator. from typing import Literal, Sequence from qutil.typecheck import check\_literals @check\_literals def my\_function(a: Sequence[int], b: Literal['forward', 'backward']):     pass \# do something \# works my\_function([1, 2, 3], 'backward') \# works because the first arguement is not checked at runtime my\_function(\{'no': 'sequence'\}, 'backward') \# runtime error because of typo in 'backward' my\_function('wrong', 'backwardd') qutil.pandas\_tools Pandas utility functions for common code patterns. consecutive\_groupby is like pandas.DataFrame.groupby but only groups consecutive rows. qutil.image Image and video processing tools. convert\_tiff converts a multipage .tif image to a video with a format of choice using moviepy.},
  organization = {Zenodo},
  version = {2024.11.1},
  keywords = {quantum computing,quantum control,quantum information,quantum physics,research software,research utilities,utility},
  file = {/home/tobias/Winhome/Zotero/storage/NF68UTLZ/14200666.html}
}
